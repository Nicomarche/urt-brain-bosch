<div class="line-following-config">
  <div class="header">
    <h3>Configuracion de Seguimiento de Linea</h3>
    <button class="btn-reset" (click)="resetDefaults()">Restaurar Valores</button>
  </div>

  <!-- AI Analysis Window -->
  <div class="ai-analysis-panel" *ngIf="debugStreamEnabled">
    <div class="ai-header">
      <h4>Analisis en Tiempo Real</h4>
      <div class="ai-indicators">
        <span class="indicator" [class.active]="debugStatus?.active">
          {{ debugStatus?.active ? 'ACTIVO' : 'INACTIVO' }}
        </span>
        <span class="indicator mode-indicator">{{ getModeDisplayName() }}</span>
      </div>
    </div>
    
    <div class="ai-content">
      <div class="ai-video-container">
        <img [src]="debugImageSrc" *ngIf="debugImageSrc" alt="Debug View" class="ai-video"/>
        <div class="no-stream" *ngIf="!debugImageSrc">
          <div class="no-stream-icon">üì∑</div>
          <p>Esperando stream de video...</p>
          <p class="hint">Selecciona una vista de debug para comenzar</p>
        </div>
      </div>
      
      <div class="ai-stats">
        <div class="stat-item">
          <span class="stat-label">Vista</span>
          <span class="stat-value">{{ debugViewName }}</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Direccion</span>
          <span class="stat-value">{{ debugStatus?.steering !== null ? (debugStatus?.steering | number:'1.1-1') + '¬∞' : '--' }}</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Velocidad</span>
          <span class="stat-value">{{ debugStatus?.speed ?? '--' }}</span>
        </div>
        <div class="stat-item" *ngIf="selectedMode !== 'hybridnets' && selectedMode !== 'supercombo'">
          <span class="stat-label">LSTR</span>
          <span class="stat-value" [class.available]="debugStatus?.lstr_available">
            {{ debugStatus?.lstr_available ? 'Disponible' : 'No disponible' }}
          </span>
        </div>
        <div class="stat-item" *ngIf="selectedMode === 'hybridnets'">
          <span class="stat-label">Servidor</span>
          <span class="stat-value" [class.available]="hybridnetsConnected">
            {{ hybridnetsConnected ? hybridnetsRoundtripMs.toFixed(0) + 'ms' : 'Desconectado' }}
          </span>
        </div>
        <div class="stat-item" *ngIf="selectedMode === 'supercombo'">
          <span class="stat-label">Servidor</span>
          <span class="stat-value" [class.available]="supercomboConnected">
            {{ supercomboConnected ? supercomboRoundtripMs.toFixed(0) + 'ms' : 'Desconectado' }}
          </span>
        </div>
      </div>
    </div>
  </div>

  <!-- Detection Mode Selection -->
  <div class="config-section">
    <div class="section-header">
      <h4>Modo de Deteccion</h4>
    </div>
    <div class="button-group mode-buttons">
      <button 
        class="mode-btn" 
        [class.selected]="selectedMode === 'opencv'"
        (click)="setMode('opencv')">
        <span class="mode-icon">üëÅÔ∏è</span>
        <span class="mode-name">OpenCV</span>
        <span class="mode-desc">Mascaras HSV + Sliding Window. Configurable, funciona sin GPU.</span>
      </button>
      <button 
        class="mode-btn" 
        [class.selected]="selectedMode === 'lstr'"
        (click)="setMode('lstr')"
        [disabled]="!lstrAvailable">
        <span class="mode-icon">ü§ñ</span>
        <span class="mode-name">LSTR AI</span>
        <span class="mode-desc">Red neuronal local. Mas preciso, no necesita calibrar HSV.</span>
        <span class="mode-badge" *ngIf="!lstrAvailable">No disponible</span>
      </button>
      <button 
        class="mode-btn" 
        [class.selected]="selectedMode === 'hybrid'"
        (click)="setMode('hybrid')"
        [disabled]="!lstrAvailable">
        <span class="mode-icon">‚ö°</span>
        <span class="mode-name">Hibrido</span>
        <span class="mode-desc">Fusion OpenCV + LSTR. Usa ambos y combina resultados.</span>
        <span class="mode-badge" *ngIf="!lstrAvailable">No disponible</span>
      </button>
      <button 
        class="mode-btn hybridnets-btn" 
        [class.selected]="selectedMode === 'hybridnets'"
        (click)="setMode('hybridnets')">
        <span class="mode-icon">üåê</span>
        <span class="mode-name">HybridNets</span>
        <span class="mode-desc">GPU remota. Envia frames por red, maxima precision.</span>
        <span class="mode-badge server-badge" *ngIf="selectedMode === 'hybridnets'">
          {{ hybridnetsConnected ? 'Conectado' : 'Desconectado' }}
        </span>
      </button>
      <button 
        class="mode-btn hybridnets-btn" 
        [class.selected]="selectedMode === 'supercombo'"
        (click)="setMode('supercombo')">
        <span class="mode-icon">üß†</span>
        <span class="mode-name">Supercombo</span>
        <span class="mode-desc">Modelo openpilot. Deteccion end-to-end con trayectoria.</span>
        <span class="mode-badge server-badge" *ngIf="selectedMode === 'supercombo'">
          {{ supercomboConnected ? 'Conectado' : 'Desconectado' }}
        </span>
      </button>
    </div>
  </div>

  <!-- HybridNets Server Configuration -->
  <div class="config-section hybridnets-config" *ngIf="selectedMode === 'hybridnets'">
    <div class="section-header">
      <h4>Servidor HybridNets</h4>
      <span class="connection-status" [class.connected]="hybridnetsConnected">
        {{ hybridnetsConnected ? 'Conectado' : 'Desconectado' }}
      </span>
    </div>

    <div class="server-url-row">
      <label>URL del servidor</label>
      <input type="text" class="server-url-input" 
             [(ngModel)]="hybridnetsServerUrl" 
             (change)="setHybridnetsServerUrl(hybridnetsServerUrl)"
             placeholder="ws://172.20.10.4:8500/ws/steering"/>
    </div>

    <div class="server-info-grid">
      <div class="server-info-item">
        <span class="info-label">Endpoint</span>
        <div class="btn-group-small">
          <button [class.selected]="hybridnetsServerUrl.endsWith('/ws/steering')"
                  (click)="setHybridnetsEndpoint('/ws/steering')">
            Steering
          </button>
          <button [class.selected]="hybridnetsServerUrl.endsWith('/ws/inference')"
                  (click)="setHybridnetsEndpoint('/ws/inference')">
            Completo
          </button>
        </div>
      </div>
      <div class="server-info-item">
        <span class="info-label">Calidad JPEG</span>
        <div class="btn-group-small">
          <button *ngFor="let q of [40, 55, 70, 85]"
                  [class.selected]="hybridnetsJpegQuality === q"
                  (click)="setHybridnetsJpegQuality(q)">{{ q }}%</button>
        </div>
      </div>
      <div class="server-info-item">
        <span class="info-label">Timeout (s)</span>
        <div class="btn-group-small">
          <button *ngFor="let t of [0.5, 1.0, 2.0, 5.0]"
                  [class.selected]="hybridnetsTimeout === t"
                  (click)="setHybridnetsTimeout(t)">{{ t }}s</button>
        </div>
      </div>
    </div>

    <div class="server-stats" *ngIf="hybridnetsConnected">
      <div class="server-stat">
        <span class="stat-label">Roundtrip</span>
        <span class="stat-value" [class.good]="hybridnetsRoundtripMs < 50" [class.warn]="hybridnetsRoundtripMs >= 50 && hybridnetsRoundtripMs < 100" [class.bad]="hybridnetsRoundtripMs >= 100">
          {{ hybridnetsRoundtripMs | number:'1.0-0' }}ms
        </span>
      </div>
      <div class="server-stat">
        <span class="stat-label">Server FPS</span>
        <span class="stat-value">{{ hybridnetsServerFps | number:'1.0-0' }}</span>
      </div>
    </div>

    <p class="hybridnets-hint">
      El servidor debe estar corriendo <code>python server.py</code> en una maquina con GPU.
      Conecta ambos dispositivos a la misma red local.
    </p>
  </div>

  <!-- Supercombo Server Configuration -->
  <div class="config-section hybridnets-config" *ngIf="selectedMode === 'supercombo'">
    <div class="section-header">
      <h4>Servidor Supercombo (openpilot)</h4>
      <span class="connection-status" [class.connected]="supercomboConnected">
        {{ supercomboConnected ? 'Conectado' : 'Desconectado' }}
      </span>
    </div>

    <div class="server-url-row">
      <label>URL del servidor</label>
      <input type="text" class="server-url-input" 
             [(ngModel)]="supercomboServerUrl" 
             (change)="setSupercomboServerUrl(supercomboServerUrl)"
             placeholder="ws://172.20.10.4:8500/ws/steering"/>
    </div>

    <div class="server-info-grid">
      <div class="server-info-item">
        <span class="info-label">Endpoint</span>
        <div class="btn-group-small">
          <button [class.selected]="supercomboServerUrl.endsWith('/ws/steering')"
                  (click)="setSupercomboEndpoint('/ws/steering')">
            Steering
          </button>
          <button [class.selected]="supercomboServerUrl.endsWith('/ws/inference')"
                  (click)="setSupercomboEndpoint('/ws/inference')">
            Completo
          </button>
        </div>
      </div>
      <div class="server-info-item">
        <span class="info-label">Calidad JPEG</span>
        <div class="btn-group-small">
          <button *ngFor="let q of [40, 55, 70, 85]"
                  [class.selected]="supercomboJpegQuality === q"
                  (click)="setSupercomboJpegQuality(q)">{{ q }}%</button>
        </div>
      </div>
      <div class="server-info-item">
        <span class="info-label">Timeout (s)</span>
        <div class="btn-group-small">
          <button *ngFor="let t of [0.5, 1.0, 2.0, 5.0]"
                  [class.selected]="supercomboTimeout === t"
                  (click)="setSupercomboTimeout(t)">{{ t }}s</button>
        </div>
      </div>
    </div>

    <div class="server-stats" *ngIf="supercomboConnected">
      <div class="server-stat">
        <span class="stat-label">Roundtrip</span>
        <span class="stat-value" [class.good]="supercomboRoundtripMs < 50" [class.warn]="supercomboRoundtripMs >= 50 && supercomboRoundtripMs < 100" [class.bad]="supercomboRoundtripMs >= 100">
          {{ supercomboRoundtripMs | number:'1.0-0' }}ms
        </span>
      </div>
      <div class="server-stat">
        <span class="stat-label">Server FPS</span>
        <span class="stat-value">{{ supercomboServerFps | number:'1.0-0' }}</span>
      </div>
    </div>

    <p class="hybridnets-hint">
      Modelo Supercombo de openpilot (comma.ai). Requiere <code>supercombo.onnx</code> en el servidor.<br>
      Setup: <code>cd aiserver && python setup_supercombo.py</code> | Config: <code>ENGINE_TYPE = "supercombo"</code>
    </p>
  </div>

  <!-- LSTR Model Selection -->
  <div class="config-section" *ngIf="selectedMode === 'lstr' || selectedMode === 'hybrid'">
    <div class="section-header">
      <h4>Modelo LSTR</h4>
    </div>
    <p class="section-hint">Selecciona el tamano del modelo. Mas grande = mas preciso pero mas lento.</p>
    <div class="button-group model-buttons">
      <button 
        *ngFor="let model of lstrModels"
        class="model-btn" 
        [class.selected]="selectedLstrModel === model.id"
        (click)="setLstrModel(model.id)">
        <span class="model-name">{{ model.name }}</span>
        <span class="model-resolution">{{ model.resolution }}</span>
        <span class="model-speed">{{ model.speed }}</span>
      </button>
    </div>
  </div>

  <!-- Debug View Selection -->
  <div class="config-section">
    <div class="section-header">
      <h4>Vista de Debug</h4>
    </div>
    <div class="button-group view-buttons">
      <button 
        *ngFor="let view of debugViews"
        class="view-btn" 
        [class.selected]="selectedDebugView === view.id"
        (click)="setDebugView(view.id)">
        <span class="view-icon">{{ view.icon }}</span>
        <span class="view-name">{{ view.name }}</span>
      </button>
    </div>
    <p class="view-description" *ngIf="getSelectedViewDescription()">
      {{ getSelectedViewDescription() }}
    </p>
  </div>

  <!-- Stream Settings -->
  <div class="config-section compact">
    <div class="section-header">
      <h4>Configuracion del Stream</h4>
    </div>
    <div class="inline-controls">
      <div class="control-item">
        <label>FPS</label>
        <div class="btn-group-small">
          <button *ngFor="let fps of [1, 5, 10, 15]" 
                  [class.selected]="streamFps === fps"
                  (click)="setStreamFps(fps)">{{ fps }}</button>
        </div>
      </div>
      <div class="control-item">
        <label>Calidad</label>
        <div class="btn-group-small">
          <button *ngFor="let q of [30, 50, 70, 90]" 
                  [class.selected]="streamQuality === q"
                  (click)="setStreamQuality(q)">{{ q }}%</button>
        </div>
      </div>
      <div class="control-item">
        <label>Escala</label>
        <div class="btn-group-small">
          <button *ngFor="let s of [0.25, 0.5, 0.75, 1.0]" 
                  [class.selected]="streamScale === s"
                  (click)="setStreamScale(s)">{{ s * 100 }}%</button>
        </div>
      </div>
    </div>
  </div>

  <!-- ==================== SPEED (always visible) ==================== -->
  <div class="config-section">
    <div class="section-header clickable" (click)="toggleSection('speed')">
      <h4>üöó Velocidad</h4>
      <span class="toggle-icon">{{ expandedSections['speed'] ? '‚ñº' : '‚ñ∂' }}</span>
    </div>
    <div class="slider-content" *ngIf="expandedSections['speed']">
      <p class="section-hint">Limites de velocidad del coche. En modos remotos (HybridNets/Supercombo) la velocidad se calcula segun el angulo de giro.</p>
      <div class="slider-row" *ngFor="let slider of getSlidersByGroup('speed')">
        <label>{{ slider.label }}</label>
        <input type="range" [min]="slider.min" [max]="slider.max" [step]="slider.step"
               [(ngModel)]="slider.value" (input)="onSliderChange(slider)"/>
        <span class="value">{{ slider.value }}</span>
      </div>
    </div>
  </div>

  <!-- ==================== PID (opencv / hybrid only) ==================== -->
  <div class="config-section" *ngIf="isSectionVisibleForMode('pid')">
    <div class="section-header clickable" (click)="toggleSection('pid')">
      <h4>üéØ Control PID</h4>
      <span class="toggle-icon">{{ expandedSections['pid'] ? '‚ñº' : '‚ñ∂' }}</span>
    </div>
    <div class="slider-content" *ngIf="expandedSections['pid']">
      <p class="section-hint">Controlador Proporcional-Integral-Derivativo. Kp corrige el error actual, Ki corrige errores acumulados, Kd amortigua oscilaciones. El error se mide en pixeles.</p>
      <div class="slider-row" *ngFor="let slider of getSlidersByGroup('pid')">
        <label>{{ slider.label }}</label>
        <input type="range" [min]="slider.min" [max]="slider.max" [step]="slider.step"
               [(ngModel)]="slider.value" (input)="onSliderChange(slider)"/>
        <span class="value">{{ slider.value }}</span>
      </div>
    </div>
  </div>

  <!-- ==================== Feed-Forward (opencv / hybrid only) ==================== -->
  <div class="config-section" *ngIf="isSectionVisibleForMode('feedforward')">
    <div class="section-header clickable" (click)="toggleSection('feedforward')">
      <h4>üîÆ Prediccion de Curvas (Feed-Forward)</h4>
      <span class="toggle-icon">{{ expandedSections['feedforward'] ? '‚ñº' : '‚ñ∂' }}</span>
    </div>
    <div class="slider-content" *ngIf="expandedSections['feedforward']">
      <p class="section-hint">Anticipa curvas usando la curvatura detectada. Peso FF=0 usa solo PID, FF=1 usa solo prediccion. Combina ambos para mejor respuesta en curvas.</p>
      <div class="slider-row" *ngFor="let slider of getSlidersByGroup('feedforward')">
        <label>{{ slider.label }}</label>
        <input type="range" [min]="slider.min" [max]="slider.max" [step]="slider.step"
               [(ngModel)]="slider.value" (input)="onSliderChange(slider)"/>
        <span class="value">{{ slider.value }}</span>
      </div>
    </div>
  </div>

  <!-- ==================== ROI (opencv / hybrid only) ==================== -->
  <div class="config-section" *ngIf="isSectionVisibleForMode('roi')">
    <div class="section-header clickable" (click)="toggleSection('roi')">
      <h4>üìê Region de Interes (ROI)</h4>
      <span class="toggle-icon">{{ expandedSections['roi'] ? '‚ñº' : '‚ñ∂' }}</span>
    </div>
    <div class="slider-content" *ngIf="expandedSections['roi']">
      <p class="section-hint">Define que parte de la imagen se analiza. Inicio/Fin Altura controla la franja vertical (0=arriba, 1=abajo). Los margenes recortan los lados para ignorar el entorno.</p>
      <div class="slider-row" *ngFor="let slider of getSlidersByGroup('roi')">
        <label>{{ slider.label }}</label>
        <input type="range" [min]="slider.min" [max]="slider.max" [step]="slider.step"
               [(ngModel)]="slider.value" (input)="onSliderChange(slider)"/>
        <span class="value">{{ slider.value }}</span>
      </div>
    </div>
  </div>

  <!-- ==================== Image Processing (opencv / hybrid only) ==================== -->
  <div class="config-section" *ngIf="isSectionVisibleForMode('image')">
    <div class="section-header clickable" (click)="toggleSection('image')">
      <h4>‚òÄÔ∏è Procesamiento de Imagen</h4>
      <span class="toggle-icon">{{ expandedSections['image'] ? '‚ñº' : '‚ñ∂' }}</span>
    </div>
    <div class="slider-content" *ngIf="expandedSections['image']">
      <p class="section-hint">Ajustes de brillo, contraste y filtros previos a la deteccion. Brillo compensa iluminacion pobre. Blur reduce ruido. Morph cierra huecos en las lineas detectadas.</p>
      <div class="slider-row" *ngFor="let slider of getSlidersByGroup('image')">
        <label>{{ slider.label }}</label>
        <input type="range" [min]="slider.min" [max]="slider.max" [step]="slider.step"
               [(ngModel)]="slider.value" (input)="onSliderChange(slider)"/>
        <span class="value">{{ slider.value }}</span>
      </div>
    </div>
  </div>

  <!-- ==================== HSV White (opencv / hybrid only) ==================== -->
  <div class="config-section" *ngIf="isSectionVisibleForMode('white')">
    <div class="section-header clickable" (click)="toggleSection('white')">
      <h4>‚ö™ Linea Blanca (HSV)</h4>
      <span class="toggle-icon">{{ expandedSections['white'] ? '‚ñº' : '‚ñ∂' }}</span>
    </div>
    <div class="slider-content" *ngIf="expandedSections['white']">
      <p class="section-hint">Rango HSV para detectar lineas blancas. H=tono (color), S=saturacion (pureza), V=valor (brillo). Usa la vista de debug "Blanco" para calibrar en tiempo real.</p>
      <div class="slider-row" *ngFor="let slider of getSlidersByGroup('white')">
        <label>{{ slider.label }}</label>
        <input type="range" [min]="slider.min" [max]="slider.max" [step]="slider.step"
               [(ngModel)]="slider.value" (input)="onSliderChange(slider)"/>
        <span class="value">{{ slider.value }}</span>
      </div>
    </div>
  </div>

  <!-- ==================== HSV Yellow (opencv / hybrid only) ==================== -->
  <div class="config-section" *ngIf="isSectionVisibleForMode('yellow')">
    <div class="section-header clickable" (click)="toggleSection('yellow')">
      <h4>üü° Linea Amarilla (HSV)</h4>
      <span class="toggle-icon">{{ expandedSections['yellow'] ? '‚ñº' : '‚ñ∂' }}</span>
    </div>
    <div class="slider-content" *ngIf="expandedSections['yellow']">
      <p class="section-hint">Rango HSV para detectar lineas amarillas. El H min puede ser mayor que H max (rango envolvente que cruza 0/180). Usa la vista "Amarillo" para calibrar.</p>
      <div class="slider-row" *ngFor="let slider of getSlidersByGroup('yellow')">
        <label>{{ slider.label }}</label>
        <input type="range" [min]="slider.min" [max]="slider.max" [step]="slider.step"
               [(ngModel)]="slider.value" (input)="onSliderChange(slider)"/>
        <span class="value">{{ slider.value }}</span>
      </div>
    </div>
  </div>

  <!-- ==================== Edge Detection (opencv / hybrid only) ==================== -->
  <div class="config-section" *ngIf="isSectionVisibleForMode('edge')">
    <div class="section-header clickable" (click)="toggleSection('edge')">
      <h4>üìè Deteccion de Bordes</h4>
      <span class="toggle-icon">{{ expandedSections['edge'] ? '‚ñº' : '‚ñ∂' }}</span>
    </div>
    <div class="slider-content" *ngIf="expandedSections['edge']">
      <p class="section-hint">Canny detecta bordes por gradiente de intensidad (bajo/alto = umbrales de hist√©resis). Hough transforma bordes en lineas rectas: umbral=votos minimos, longitud minima y espacio maximo entre segmentos.</p>
      <div class="slider-row" *ngFor="let slider of getSlidersByGroup('edge')">
        <label>{{ slider.label }}</label>
        <input type="range" [min]="slider.min" [max]="slider.max" [step]="slider.step"
               [(ngModel)]="slider.value" (input)="onSliderChange(slider)"/>
        <span class="value">{{ slider.value }}</span>
      </div>
    </div>
  </div>

  <!-- ==================== BFMC Parameters (opencv / hybrid only) ==================== -->
  <div class="config-section" *ngIf="isSectionVisibleForMode('bfmc')">
    <div class="section-header clickable" (click)="toggleSection('bfmc')">
      <h4>üèéÔ∏è Parametros BFMC</h4>
      <span class="toggle-icon">{{ expandedSections['bfmc'] ? '‚ñº' : '‚ñ∂' }}</span>
    </div>
    <div class="slider-content" *ngIf="expandedSections['bfmc']">
      <p class="section-hint">Parametros del estilo BFMC. Umbral binario convierte a blanco/negro (reintento usa valor mas bajo si no detecta lineas). Filtro de angulo descarta lineas casi horizontales. Merge agrupa lineas cercanas.</p>
      <div class="slider-row" *ngFor="let slider of getSlidersByGroup('bfmc')">
        <label>{{ slider.label }}</label>
        <input type="range" [min]="slider.min" [max]="slider.max" [step]="slider.step"
               [(ngModel)]="slider.value" (input)="onSliderChange(slider)"/>
        <span class="value">{{ slider.value }}</span>
      </div>
    </div>
  </div>

  <!-- ==================== Adaptive Lighting (opencv / hybrid only) ==================== -->
  <div class="config-section" *ngIf="isSectionVisibleForMode('adaptive')">
    <div class="section-header clickable" (click)="toggleSection('adaptive')">
      <h4>üí° Iluminacion Adaptativa</h4>
      <span class="toggle-icon">{{ expandedSections['adaptive'] ? '‚ñº' : '‚ñ∂' }}</span>
    </div>
    <div class="slider-content" *ngIf="expandedSections['adaptive']">
      <p class="section-hint">CLAHE normaliza el contraste localmente (compensa sombras/reflejos). Blanco adaptativo ajusta el umbral automaticamente segun la imagen. Gradiente fallback usa bordes cuando el color falla.</p>
      <div class="toggle-row">
        <label>CLAHE</label>
        <button class="toggle-btn" [class.active]="useClahe" (click)="toggleClahe()">
          {{ useClahe ? 'ON' : 'OFF' }}
        </button>
      </div>
      <div class="toggle-row">
        <label>Blanco Adaptativo</label>
        <button class="toggle-btn" [class.active]="useAdaptiveWhite" (click)="toggleAdaptiveWhite()">
          {{ useAdaptiveWhite ? 'ON' : 'OFF' }}
        </button>
      </div>
      <div class="toggle-row">
        <label>Fallback Gradiente</label>
        <button class="toggle-btn" [class.active]="useGradientFallback" (click)="toggleGradientFallback()">
          {{ useGradientFallback ? 'ON' : 'OFF' }}
        </button>
      </div>
      <div class="slider-row" *ngFor="let slider of getSlidersByGroup('adaptive')">
        <label>{{ slider.label }}</label>
        <input type="range" [min]="slider.min" [max]="slider.max" [step]="slider.step"
               [(ngModel)]="slider.value" (input)="onSliderChange(slider)"/>
        <span class="value">{{ slider.value }}</span>
      </div>
    </div>
  </div>

  <!-- Curve Recovery Section -->
  <div class="config-section" *ngIf="isSectionVisibleForMode('recovery')">
    <div class="section-header" (click)="toggleSection('recovery')">
      <h3>Recuperacion en Curva</h3>
      <span class="toggle-icon">{{ expandedSections['recovery'] ? '‚ñº' : '‚ñ∂' }}</span>
    </div>
    <div class="section-content" *ngIf="expandedSections['recovery']">
      <p class="section-hint">Si el auto llega a max giro y el error NO baja (no se esta corrigiendo), frena y retrocede. El tiempo de reversa escala con el error: poco error = reversa corta, mucho error = reversa larga. "Ratio Error Corrigiendo" define el umbral: si el error baja a ese ratio, NO activa reversa (el auto se esta corrigiendo solo).</p>
      <div class="toggle-row">
        <label>Recuperacion Curva</label>
        <button class="toggle-btn" [class.active]="useCurveRecovery" (click)="toggleCurveRecovery()">
          {{ useCurveRecovery ? 'ON' : 'OFF' }}
        </button>
      </div>
      <div class="slider-row" *ngFor="let slider of getSlidersByGroup('recovery')">
        <label>{{ slider.label }}</label>
        <input type="range" [min]="slider.min" [max]="slider.max" [step]="slider.step"
               [(ngModel)]="slider.value" (input)="onSliderChange(slider)"/>
        <span class="value">{{ slider.value }}</span>
      </div>
    </div>
  </div>

  <!-- Mode-specific hint when in remote modes -->
  <div class="config-section remote-mode-hint" *ngIf="selectedMode === 'hybridnets' || selectedMode === 'supercombo'">
    <p>En modo {{ getModeDisplayName() }}, el procesamiento de imagen (brillo, HSV, bordes, etc.) lo hace el servidor remoto. Solo puedes ajustar velocidad y configuracion del servidor desde aqui.</p>
  </div>

  <div class="config-section remote-mode-hint" *ngIf="selectedMode === 'lstr'">
    <p>En modo LSTR AI, la red neuronal detecta los carriles directamente. Los filtros HSV, bordes y procesamiento de imagen no se usan - solo se aplican velocidad, PID y parametros de control.</p>
  </div>

  <div class="actions">
    <button class="btn-apply" (click)="sendConfig()">Aplicar Configuracion</button>
  </div>
</div>
